require 'bundler/setup'
require 'mini_portile2'
require 'pathname'

ENV['MAKEFLAGS'] ||= "-j#{`nproc`}"

TARGET = Pathname(ENV.fetch('TARGET', '/opt')).realpath
PUBKEY = (Pathname(__dir__) + 'gnupg.asc').read

task :default => :package

task :init

$packages = {}
def def_package(name, version, depends: [], &block)
  name = name.to_s
  id = name.to_sym
  depends = depends.map(&:to_sym)

  $packages[id] = {
    depends: depends,
  }

  t = Rake::Task.define_task(:"init:#{id}" => depends.map {|depid| :"init:#{depid}"}) do
    dep_recipes = depends.map {|id| $packages.fetch(id)[:recipe] }
    recipe = MiniPortile.new(name, version)
    block.yield(recipe, dep_recipes)
    recipe.target = TARGET
    def recipe.install
      return if installed?
      execute('install', %Q(#{make_cmd} install-strip),)
    end

    $packages[id][:recipe] = recipe
  end

  Rake::Task[:init].enhance([t])
end

def_package('gnupg', '2.2.18', depends: %i[libgpg-error libksba libassuan libgcrypt ntbtls npth]) do |r, deps|
  rpath = deps.map {|dep| "#{dep.path}/lib" }.join(?:)
  ldflags = "-Wl,-rpath,#{rpath}"

  r.files << {
    gpg:{
      key: PUBKEY,
      signature_url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2.sig",
    },
    url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2",
  }
  r.configure_options = %W[--disable-nls --disable-gpgsm --disable-gpgtar --disable-wks-tools --disable-photo-viewers --disable-card-support --disable-doc --enable-rpath LDFLAGS=#{ldflags}]
end

def_package('libgpg-error', '1.36') do |r|
  r.files << {
    gpg:{
      key: PUBKEY,
      signature_url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2.sig",
    },
    url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2",
  }
  r.configure_options = %W[--disable-nls --enable-shared --disable-static --with-pic --disable-doc]
end

def_package('libgcrypt', '1.8.5', depends: %i[libgpg-error]) do |r|
  r.files << {
    gpg:{
      key: PUBKEY,
      signature_url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2.sig",
    },
    url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2",
  }
  r.configure_options = %W[--enable-shared --disable-static --with-pic --disable-doc]
end

def_package('libksba', '1.3.5', depends: %i[libgpg-error]) do |r|
  r.files << {
    gpg:{
      key: PUBKEY,
      signature_url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2.sig",
    },
    url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2",
  }
  r.configure_options = %W[--enable-shared --disable-static --with-pic --disable-doc]
end

def_package('libassuan', '2.5.3', depends: %i[libgpg-error]) do |r|
  r.files << {
    gpg:{
      key: PUBKEY,
      signature_url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2.sig",
    },
    url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2",
  }
  r.configure_options = %W[--enable-shared --disable-static --with-pic --disable-doc]
end

def_package('ntbtls', '0.1.2', depends: %i[libgpg-error libgcrypt libksba]) do |r|
  r.files << {
    gpg:{
      key: PUBKEY,
      signature_url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2.sig",
    },
    url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2",
  }
  r.configure_options = %W[--enable-shared --disable-static --with-pic --disable-doc]
end

def_package('npth', '1.6') do |r|
  r.files << {
    gpg:{
      key: PUBKEY,
      signature_url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2.sig",
    },
    url: "https://gnupg.org/ftp/gcrypt/#{r.name}/#{r.name}-#{r.version}.tar.bz2",
  }
  r.configure_options = %W[--enable-shared --disable-static --with-pic --disable-doc]
end

def recipe(id)
  $packages[id.to_sym][:recipe]
end

desc "Clean everything"
task :clean => $packages.keys.map {|id| :"clean:#{id}" }

namespace :clean do
  $packages.each do |id, package|
    desc "Clean #{id}"
    task id => :init do
      recipe = package[:recipe]
      FileUtils.rm_rf(recipe.send(:tmp_path))
    end
  end
end

desc "Fetch everything"
task :fetch => $packages.keys.map {|id| :"fetch:#{id}" }

namespace :fetch do
  $packages.each do |id, package|
    desc "Fetch #{id}"
    task id => :init do
      recipe = package[:recipe]
      recipe.download unless recipe.downloaded?
    end
  end
end

desc 'Build everything'
task :build => $packages.keys.map {|id| :"build:#{id}" }

namespace :build do
  $packages.each do |id, package|
    desc "Build #{id}"
    task id => [:init, *package[:depends]] do
      recipe = package[:recipe]
      recipe.cook
      recipe.activate
    end
  end
end

task :symlink => :init do
  bin_dir = TARGET.join('bin').tap(&:mkpath)

  $packages.each do |_, pkg|
    FileUtils.ln_sf(Pathname(pkg[:recipe].path).join('bin').children, bin_dir)
  end
end

desc 'Create archive'
task :package => [:build, :symlink] do
  archive = (Pathname(__dir__) + 'pkg').tap(&:mkpath) + 'layer.zip'
  rm_f archive

  pkgs = $packages.map {|_, pkg| Pathname(pkg[:recipe].path).relative_path_from(TARGET).to_s }

  Dir.chdir(TARGET) do
    sh 'zip', '-yr', archive.to_s, 'bin', *pkgs
  end
end
